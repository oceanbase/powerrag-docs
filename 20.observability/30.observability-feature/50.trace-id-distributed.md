# Trace ID 与分布式追踪（Trace IDs & Distributed Tracing）

PowerRAG 支持在系统中使用自定义的追踪 ID（例如 messageId、traceId、correlationId）来实现分布式追踪与跨服务追踪链路的关联与查找。

默认情况下，PowerRAG 会为所有记录的事件分配随机 ID（如 uuid、cuid）。对于基于 OpenTelemetry (OTEL) 的 SDK，PowerRAG 会分配随机的 32 位十六进制字符串作为 Trace ID，以及 16 位十六进制字符串作为 Observation（观测点）ID。

## 数据模型
在 PowerRAG 中，Trace ID 的特性如下：

+ 必须在同一项目中唯一
+ 用于识别并关联属于同一调用链的 Observations
+ 可用于跨服务的分布式追踪
+ 支持 upsert 操作（基于 ID 的创建或更新）
+ 对于基于 OTEL 的 SDK：
    - Trace ID 为 32 位小写十六进制字符串
    - Observation ID 为 16 位小写十六进制字符串

## 使用方法
### Python SDK
Python SDK 默认使用 W3C Trace Context 格式的 ID：

+ Trace ID：32 位小写十六进制字符串
+ Observation（span）ID：16 位小写十六进制字符串

#### 使用装饰器定义自定义 Trace ID
```python
from langfuse import observe, get_client
import uuid

@observe()
def process_user_request(user_id, request_data):
    # 函数逻辑
    pass

# 通过关键字参数传入自定义 trace ID
external_trace_id = "custom-" + str(uuid.uuid4())

# 基于同一输入生成一致的 trace ID
langfuse = get_client()
trace_id = langfuse.create_trace_id(seed=external_trace_id)  # 32 位小写十六进制字符串，基于 seed 确定性生成

process_user_request(
    user_id="user_123",
    request_data={"query": "hello"},
    langfuse_trace_id=trace_id
)
```

#### 生成确定性 Trace ID (Deterministic Trace IDs)
你可以通过 create_trace_id() 从任意字符串生成确定性 Trace ID：

```python
from langfuse import get_client

langfuse = get_client()

# 从外部 ID 生成确定性 trace ID
external_id = "request_12345"
trace_id = langfuse.create_trace_id(seed=external_id)

# 在 span 中使用该 trace ID
with langfuse.start_as_current_span(
    name="process-request",
    trace_context={"trace_id": trace_id}
) as span:
    # 代码逻辑
    pass
```

#### 手动创建带自定义 Trace Context 的 Span
```python
from langfuse import get_client

langfuse = get_client()

# 通过 trace_context 参数指定已有 trace ID
with langfuse.start_as_current_span(
    name="my-operation",
    trace_context={
        "trace_id": "abcdef1234567890abcdef1234567890",  # 必须是 32 位十六进制字符串
        "parent_span_id": "fedcba0987654321"  # 可选，16 位十六进制字符串
    }
) as span:
    print(f"This span has trace_id: {span.trace_id}")
    # 代码逻辑
```

#### 访问当前 Trace ID
```python
from langfuse import get_client

langfuse = get_client()

with langfuse.start_as_current_span(name="outer-operation") as span:
    # 获取当前 span 的 trace ID
    current_trace_id = langfuse.get_current_trace_id()
    current_span_id = langfuse.get_current_observation_id()

    print(f"Current trace ID: {current_trace_id}")
```

### JS/TS SDK
#### 获取当前 Trace ID
可以通过 getActiveTraceId 方法获取当前激活的 Trace ID：

```typescript
import { startObservation, getActiveTraceId } from "@langfuse/tracing";

await startObservation("run", async (span) => {
  const traceId = getActiveTraceId();
  console.log(`Current trace ID: ${traceId}`);
});
```

#### 生成确定性 Trace ID
在使用指定的 traceId 启动新 Trace 时，必须同时提供一个任意的 parentSpanId，以作为父级观测点的占位符。父 Span 实际上并不存在，仅用于继承 Trace ID，因此其值只需为有效的 16 位十六进制字符串。您可以通过 createTraceId 从任意字符串生成确定性 Trace ID，用于将 Trace 与外部系统（如工单系统）中的 ID 进行关联。

```typescript
import { createTraceId, startObservation } from "@langfuse/tracing";

const externalId = "support-ticket-54321";

// 从外部 ID 生成确定性 traceId
const langfuseTraceId = await createTraceId(externalId);

// 使用该 traceId 启动新 trace
const rootSpan = startObservation(
  "process-ticket",
  {},
  {
    parentSpanContext: {
      traceId: langfuseTraceId,
      spanId: "0123456789abcdef", // 有效的 16 位十六进制字符串；父 span 实际不存在，仅用于继承 trace ID
      traceFlags: 1, // 标记该 trace 已采样
    },
  }
);

// 后续可以基于相同的 externalId 重新生成同样的 traceId，用于评分或数据查询
const scoringTraceId = await createTraceId(externalId);
// scoringTraceId 将与 langfuseTraceId 保持一致

```

当设置了 parentSpanContext 时，新建的 Span 将不再继承当前激活的 Span 上下文，而是独立形成新的追踪链路。

