# Tags

Tags are used to categorize and filter traces. In PowerRAG, you can add tags to traces in the following two ways:

1. Add directly when creating a trace through PowerRAG SDK or related integration interfaces.
2. Add tags to existing traces in the console.

To add tags to a trace, simply pass a string array to the `tags` field of the trace object. Each tag is a string, and a single trace can contain multiple tags. Currently, tags can only be added and cannot be deleted.

## How to use

### Python SDK

+ Using the @observe() decorator

```python
from langfuse import observe, get_client

langfuse = get_client()

@observe()
def my_function():
    # ... business logic processing ...
    # Add tags to current trace
    langfuse.update_current_trace(tags=["tag-1", "tag-2"])
```

+ Directly creating a span or generation

```python
from langfuse import get_client
langfuse = get_client()

# Add tags when creating root span
with langfuse.start_as_current_span(name="my-operation") as root_span:
    # Add tags to current trace
    root_span.update_trace(tags=["tag-1", "tag-2"])

    # Can continue adding tags in any span within the same trace
    with root_span.start_as_current_generation(name="llm-call", model="gpt-4o") as gen:
        # Processing logic...
        gen.update_trace(tags=["llm-gen"])  # Add additional tags to the same trace
```

+ Updating tags without direct span reference

```python
with langfuse.start_as_current_span(name="another-operation"):
    # ... processing logic ...
    langfuse.update_current_trace(tags=["processing", "beta-feature"])
```

### JS/TS SDK

+ Using context managers

```typescript
import {
  startActiveObservation,
  startObservation,
  updateActiveTrace,
} from "@langfuse/tracing";

await startActiveObservation("context-manager", async (span) => {
  span.update({
    input: { query: "What is the capital of France?" },
  });

  updateActiveTrace({
    tags: ["tag-1", "tag-2"],
  });
});
```

+ Using observe wrapper

```typescript
import { observe, updateActiveTrace } from "@langfuse/tracing";

// Existing function
async function fetchData(source: string) {
  updateActiveTrace({
    tags: ["tag-1", "tag-2"],
  });

  // ... data fetching logic ...
  return { data: `some data from ${source}` };
}

// Use observe wrapper function
const tracedFetchData = observe(fetchData, {
  name: "observe-wrapper",
});

const result = await tracedFetchData("API");
```

+ Manually creating a span

```typescript
import { startObservation } from "@langfuse/tracing";

const span = startObservation("manual-observation", {
  input: { query: "What is the capital of France?" },
});

span.updateTrace({
  tags: ["tag-1", "tag-2"],
});

span.update({ output: "Paris" }).end();
```

## Use cases

Tags are a flexible metadata mechanism that can help you better organize and analyze traces. When designing a tag system, it is recommended to choose tags that reflect business semantics or environmental characteristics based on actual monitoring and analysis needs.

Common tag usage includes:

+ **Version differentiation**: Identify different versions of applications, such as app-v1, app-v2.
+ **Model strategy**: Identify LLM strategies used, such as rag, one-shot, few-shot.
+ **Environment information**: Identify application runtime environments, such as local, staging, prod.
+ **Business modules**: Identify business functions or modules, such as chat, retrieval, evaluation.

By properly setting tags, you can easily filter traces, analyze performance metrics, or compare the performance of different models/versions in the PowerRAG console.

